/**
 * Basic user information collected during creation.
 */
export type CreateUserFormValues = Readonly<{
  first_name: string;
  last_name: string;
  email: string;
}>;

/**
 * Data that's generated by the UI form to edit the user.
 */
export type EditUserFormData = Readonly<{
  first_name: string;
  last_name: string;
  email: string;
  roles: string[];
  teams: string[];
}>;

/**
 * Request body for resetting a user's password.
 */
export type ResetPasswordRequest = Readonly<{
  token: string;
  password: string;
}>;

/**
 * Status codes
 *
 * (Move to a separate module if others need this.)
 */
export const httpStatus = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  NO_DATA: 204,
  BAD_REQUEST: 400,
  NOT_AUTHORIZED: 401,
  FORBIDDEN: 403,
  UNPROCESSABLE: 422,
  INTERNAL_ERROR: 500,
  BAD_GATEWAY: 502,
};

/**
 * Run verification request with the given token.
 */
export const verify = async (token: string) => {
  const r = await fetch("/auth/verify", {
    method: "POST",
    credentials: "same-origin",
    body: JSON.stringify({ token }),
    headers: [["Content-Type", "application/json"]],
  });

  let json;

  switch (r.status) {
    case httpStatus.OK:
      return;
    case httpStatus.BAD_REQUEST:
      json = await r.json();
      throw new Error(json.detail);
    case httpStatus.UNPROCESSABLE:
      throw new Error("VALIDATION_ERROR");
    default:
      throw new Error("UNKNOWN_ERROR");
  }
};

/**
 * Generate a random password.
 *
 * This is only intended to be used to generate temporary passwords.
 */
export const newRandomPassword = () => {
  const sym =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!%,.^*()?".split(
      ""
    );
  let pw = "";
  for (let i = 0; i < 16; i++) {
    const rand = Math.floor(Math.random() * sym.length);
    pw += sym[rand];
  }
  return pw;
};

/**
 * Request that a user verify their email address.
 */
export const requestVerifyUser = async (email: string) => {
  // NOTE: the response from the token request is not super interesting, since
  // it always returns 202 regardless of whether the payload was incorrect.
  // Still worry about 500s, though.
  const requestVerifyResponse = await fetch("/auth/request-verify-token", {
    method: "POST",
    credentials: "same-origin",
    body: JSON.stringify({ email: email }),
    headers: [["Content-Type", "application/json"]],
  });

  if (requestVerifyResponse.status !== httpStatus.ACCEPTED) {
    const t = await requestVerifyResponse.text();
    let message = `${requestVerifyResponse.status} - ${requestVerifyResponse.statusText}`;
    if (t) {
      message += `: ${t}`;
    }
    throw new Error(message);
  }
};

/**
 * Function to submit user creation request to server.
 */
export const createUser = async (values: CreateUserFormValues) => {
  const r = await fetch("/auth/register", {
    method: "POST",
    credentials: "same-origin",
    headers: [["Content-Type", "application/json"]],
    body: JSON.stringify({
      password: newRandomPassword(),
      ...values,
    }),
  });

  if (r.status !== httpStatus.CREATED) {
    const t = await r.text();
    let message = `${r.status} - ${r.statusText}`;
    if (t) {
      message += `: ${t}`;
    }
    throw new Error(message);
  }

  const data = await r.json();
  return data["id"] as string;
};

/**
 * Function to edit an existing user.
 */
export const editUser = async (id: string, values: EditUserFormData) => {
  const r = await fetch(`/users/${id}`, {
    method: "PATCH",
    body: JSON.stringify({
      ...values,
      roles: values.roles?.map((r) => ({ id: r })),
      teams: values.teams?.map((t) => ({ id: t })),
    }),
    credentials: "same-origin",
    headers: [["Content-Type", "application/json"]],
  });

  if (r.status !== httpStatus.OK && r.status !== httpStatus.ACCEPTED) {
    const t = await r.text();
    throw new Error(`${r.statusText} - ${t}`);
  }
};

/**
 * De-active a user account.
 *
 * This will fail if the user doesn't have permission.
 */
export const deleteUser = async (userId: string) => {
  const response = await fetch(`/users/${userId}`, {
    method: "DELETE",
    credentials: "same-origin",
  });

  if (response.status !== httpStatus.NO_DATA) {
    const msg = await response.text();
    throw new Error(`${response.status} - ${msg}`);
  }
};

/**
 * Re-active a user account.
 *
 * This will fail if the user doesn't have permission.
 */
export const restoreUser = async (userId: string) => {
  const r = await fetch(`/users/${userId}`, {
    method: "PATCH",
    body: JSON.stringify({
      is_active: true,
    }),
    credentials: "same-origin",
    headers: [["Content-Type", "application/json"]],
  });

  if (r.status !== httpStatus.OK) {
    throw new Error(`${r.status} - ${r.statusText}`);
  }
};

/**
 * Reset a user's password with the given token.
 */
export const resetPassword = async (params: ResetPasswordRequest) => {
  const r = await fetch("/auth/reset-password", {
    method: "POST",
    body: JSON.stringify(params),
    credentials: "same-origin",
    headers: [["Content-Type", "application/json"]],
  });

  let json;
  switch (r.status) {
    case httpStatus.OK:
      return;
    case httpStatus.UNPROCESSABLE:
      throw new Error("VALIDATION_ERROR");
    case httpStatus.BAD_REQUEST:
      json = await r.json();
      if (json.detail.code) {
        // NOTE: there's more detail here that might be interesting to pass
        // along to the UI.
        throw new Error(json.detail.code);
      } else {
        throw new Error(json.detail);
      }
    default:
      throw new Error("UNKNOWN_ERROR");
  }
};

/**
 * Request that a password reset email be sent to the given user, if they exist.
 */
export const requestPasswordReset = async (email: string) => {
  const r = await fetch("/auth/forgot-password", {
    method: "POST",
    body: JSON.stringify({ email }),
    credentials: "same-origin",
    headers: [["Content-Type", "application/json"]],
  });

  switch (r.status) {
    case httpStatus.ACCEPTED:
      return;
    default:
      throw new Error(r.statusText);
  }
};
